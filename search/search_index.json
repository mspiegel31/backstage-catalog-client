{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"backstage-catalog-client","text":"<p>A python client for the Backstage catalog API. Only uses native python datatypes.</p>"},{"location":"#usage","title":"Usage","text":"<p>To use a ready-made client, import it and make requests</p> <pre><code>import asyncio\nimport json\nfrom backstage_catalog_client import HttpxClient\n\n\nasync def main():\n    with HttpxClient(\"https://demo.backstage.io/\") as backstage:\n        data = await backstage.get_entities()\n        for entity in data.items[:1]:\n            print(json.dumps(entity, indent=2))\n\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre> <p>if you're using the <code>HttpxClient</code>, you can also optionally pass your own fully-configured <code>httpx.AsyncClient</code> and make requests that way</p> <pre><code>import asyncio\nimport httpx\nimport json\nfrom backstage_catalog_client import HttpxClient\n\n\nasync def main():\n    client = httpx.AsyncClient(base_url=\"https://demo.backstage.io\", timeout=.5)\n    backstage = HttpxClient(client=client)\n    data = await backstage.get_entities()\n    for entity in data.items[:1]:\n        print(json.dumps(entity, indent=2))\n\n    # important!  don't forget to clean up your client\n    await client.aclose()\n\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre>"},{"location":"#building-your-own-client","title":"Building your own client","text":"<p>This package exports both an <code>AsyncCatalogApi</code> and a <code>SyncCatalogApi</code> as python protocols. You can use these to implement your own clients for the Catalog API.</p> <p>For example, if you'd like to implement your own synchronous Catalog API client:</p> <pre><code>from typing import List\nfrom backstage_catalog_client.raw_entity import RawEntity\nfrom backstage_catalog_client import SyncCatalogApi\nfrom backstage_catalog_client.models import GetEntitiesResponse\n\nclass HighPerformanceCatalogApi(SyncCatalogApi):\n    \"\"\"\n    A high-performance client that never makes a network request.\n    Stable, speedy, and (relatively) useless\n    \"\"\"\n    def getEntities(self, request=None, options=None) -&gt; GetEntitiesResponse:\n        items: List[RawEntity] = [\n            {\n                \"apiVersion\": \"backstage.io/v1alpha1\",\n                \"kind\": \"Component\",\n                \"metadata\": {\n                    \"name\": \"wayback-search\",\n                    \"namespace\": \"default\"\n                },\n                \"spec\": {\n                    \"type\": \"service\",\n                    \"owner\": \"team-a\",\n                    \"lifecycle\": \"experimental\"\n                }\n            }\n        ]\n        return GetEntitiesResponse(items=items)\n    # ... other methods ...\n\n\ndef main():\n    client: SyncCatalogApi = HighPerformanceCatalogApi()\n    data = client.get_entities()\n    for item in data.items:\n        print(item)\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"async-api/","title":"Async API","text":""},{"location":"async-api/#backstage_catalog_client.catalog_api.async_api.AsyncCatalogApi","title":"<code>AsyncCatalogApi</code>","text":"<p>             Bases: <code>Protocol</code></p> Source code in <code>backstage_catalog_client/catalog_api/async_api.py</code> <pre><code>class AsyncCatalogApi(Protocol):\n    async def get_entities(\n        self,\n        **kwargs: Unpack[GetEntitiesRequest],\n    ) -&gt; GetEntitiesResponse:\n        \"\"\"\n        List catalog entities\n\n        Args:\n            kwargs: The request object for getting entities. Defaults to None.\n\n        Returns:\n            The response object containing the entities.\n        \"\"\"\n        ...\n\n    async def query_entities(\n        self,\n        **kwargs: Unpack[QueryEntitiesKwargs],\n    ) -&gt; QueryEntitiesResponse:\n        \"\"\"\n        Gets paginated entities from the catalog.'\n\n        Args:\n            **kwargs: keyword arguments, represented as a dict.\n\n        Returns:\n            The response object containing the entities.\n\n        Examples:\n            ```python\n            response = await catalog_client.query_entities(\n                search_term='A',\n                entity_filter=[{\"kind\": \"User\"}],\n                order_fields={'field': 'metadata.name', 'order': 'asc'},\n                limit=20,\n            )\n            ```\n            this will match all entities of type group having a name starting\n            with 'A', ordered by name ascending.\n            The response will contain a maximum of 20 entities. In case\n            more than 20 entities exist, the response will contain a nextCursor\n            property that can be used to fetch the next batch of entities.\n\n            ```python\n            second_batch_response = await catalog_client\n                .query_entities(cursor=response.page_info.nextCursor)\n            ```\n            second_batch_response will contain the next batch of (maximum) 20 entities,\n            together with a prevCursor property, useful to fetch the previous batch.\n\n        \"\"\"\n        ...\n\n    async def get_entities_by_refs(\n        self,\n        refs: list[str | EntityRef],\n        **opts: Unpack[GetEntitiesByRefsOptions],\n    ) -&gt; GetEntitiesByRefsResponse:\n        \"\"\"\n        Gets a batch of entities, by their entity refs.\n        The output list of entities is of the same size and in the same order as\n        the requested list of entity refs. Entries that are not found are returned\n        as null.\n        \"\"\"\n        ...\n\n    async def get_entity_by_ref(\n        self,\n        ref: str | EntityRef,\n        **options: Unpack[CatalogRequestOptions],\n    ) -&gt; Entity | None:\n        \"\"\"\n        Gets a single entity from your backstage instance by reference (kind, namespace, name).\n\n        Args:\n            ref: The reference to the entity to fetch.\n            options: The options for the catalog request. Defaults to None.\n\n        Returns:\n            The entity if found, otherwise None.\n        \"\"\"\n\n        ...\n\n    async def get_location_by_entity(\n        self,\n        ref: str | EntityRef,\n        **opts: Unpack[CatalogRequestOptions],\n    ) -&gt; Location | None:\n        \"\"\"\n        Gets a location associated with an entity.\n\n        Args:\n            ref: The reference to the entity to fetch.\n            **opts: The options for the catalog request.\n\n        Returns:\n            the location if found, otherwise None.\n        \"\"\"\n        ...\n</code></pre>"},{"location":"async-api/#backstage_catalog_client.catalog_api.async_api.AsyncCatalogApi.get_entities","title":"<code>get_entities(**kwargs)</code>  <code>async</code>","text":"<p>List catalog entities</p> <p>Parameters:</p> Name Type Description Default <code>kwargs</code> <code>Unpack[GetEntitiesRequest]</code> <p>The request object for getting entities. Defaults to None.</p> <code>{}</code> <p>Returns:</p> Type Description <code>GetEntitiesResponse</code> <p>The response object containing the entities.</p> Source code in <code>backstage_catalog_client/catalog_api/async_api.py</code> <pre><code>async def get_entities(\n    self,\n    **kwargs: Unpack[GetEntitiesRequest],\n) -&gt; GetEntitiesResponse:\n    \"\"\"\n    List catalog entities\n\n    Args:\n        kwargs: The request object for getting entities. Defaults to None.\n\n    Returns:\n        The response object containing the entities.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"async-api/#backstage_catalog_client.catalog_api.async_api.AsyncCatalogApi.get_entities_by_refs","title":"<code>get_entities_by_refs(refs, **opts)</code>  <code>async</code>","text":"<p>Gets a batch of entities, by their entity refs. The output list of entities is of the same size and in the same order as the requested list of entity refs. Entries that are not found are returned as null.</p> Source code in <code>backstage_catalog_client/catalog_api/async_api.py</code> <pre><code>async def get_entities_by_refs(\n    self,\n    refs: list[str | EntityRef],\n    **opts: Unpack[GetEntitiesByRefsOptions],\n) -&gt; GetEntitiesByRefsResponse:\n    \"\"\"\n    Gets a batch of entities, by their entity refs.\n    The output list of entities is of the same size and in the same order as\n    the requested list of entity refs. Entries that are not found are returned\n    as null.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"async-api/#backstage_catalog_client.catalog_api.async_api.AsyncCatalogApi.get_entity_by_ref","title":"<code>get_entity_by_ref(ref, **options)</code>  <code>async</code>","text":"<p>Gets a single entity from your backstage instance by reference (kind, namespace, name).</p> <p>Parameters:</p> Name Type Description Default <code>ref</code> <code>str | EntityRef</code> <p>The reference to the entity to fetch.</p> required <code>options</code> <code>Unpack[CatalogRequestOptions]</code> <p>The options for the catalog request. Defaults to None.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Entity | None</code> <p>The entity if found, otherwise None.</p> Source code in <code>backstage_catalog_client/catalog_api/async_api.py</code> <pre><code>async def get_entity_by_ref(\n    self,\n    ref: str | EntityRef,\n    **options: Unpack[CatalogRequestOptions],\n) -&gt; Entity | None:\n    \"\"\"\n    Gets a single entity from your backstage instance by reference (kind, namespace, name).\n\n    Args:\n        ref: The reference to the entity to fetch.\n        options: The options for the catalog request. Defaults to None.\n\n    Returns:\n        The entity if found, otherwise None.\n    \"\"\"\n\n    ...\n</code></pre>"},{"location":"async-api/#backstage_catalog_client.catalog_api.async_api.AsyncCatalogApi.get_location_by_entity","title":"<code>get_location_by_entity(ref, **opts)</code>  <code>async</code>","text":"<p>Gets a location associated with an entity.</p> <p>Parameters:</p> Name Type Description Default <code>ref</code> <code>str | EntityRef</code> <p>The reference to the entity to fetch.</p> required <code>**opts</code> <code>Unpack[CatalogRequestOptions]</code> <p>The options for the catalog request.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Location | None</code> <p>the location if found, otherwise None.</p> Source code in <code>backstage_catalog_client/catalog_api/async_api.py</code> <pre><code>async def get_location_by_entity(\n    self,\n    ref: str | EntityRef,\n    **opts: Unpack[CatalogRequestOptions],\n) -&gt; Location | None:\n    \"\"\"\n    Gets a location associated with an entity.\n\n    Args:\n        ref: The reference to the entity to fetch.\n        **opts: The options for the catalog request.\n\n    Returns:\n        the location if found, otherwise None.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"async-api/#backstage_catalog_client.catalog_api.async_api.AsyncCatalogApi.query_entities","title":"<code>query_entities(**kwargs)</code>  <code>async</code>","text":"<p>Gets paginated entities from the catalog.'</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <code>Unpack[QueryEntitiesKwargs]</code> <p>keyword arguments, represented as a dict.</p> <code>{}</code> <p>Returns:</p> Type Description <code>QueryEntitiesResponse</code> <p>The response object containing the entities.</p> <p>Examples:</p> <p><pre><code>response = await catalog_client.query_entities(\n    search_term='A',\n    entity_filter=[{\"kind\": \"User\"}],\n    order_fields={'field': 'metadata.name', 'order': 'asc'},\n    limit=20,\n)\n</code></pre> this will match all entities of type group having a name starting with 'A', ordered by name ascending. The response will contain a maximum of 20 entities. In case more than 20 entities exist, the response will contain a nextCursor property that can be used to fetch the next batch of entities.</p> <p><pre><code>second_batch_response = await catalog_client\n    .query_entities(cursor=response.page_info.nextCursor)\n</code></pre> second_batch_response will contain the next batch of (maximum) 20 entities, together with a prevCursor property, useful to fetch the previous batch.</p> Source code in <code>backstage_catalog_client/catalog_api/async_api.py</code> <pre><code>async def query_entities(\n    self,\n    **kwargs: Unpack[QueryEntitiesKwargs],\n) -&gt; QueryEntitiesResponse:\n    \"\"\"\n    Gets paginated entities from the catalog.'\n\n    Args:\n        **kwargs: keyword arguments, represented as a dict.\n\n    Returns:\n        The response object containing the entities.\n\n    Examples:\n        ```python\n        response = await catalog_client.query_entities(\n            search_term='A',\n            entity_filter=[{\"kind\": \"User\"}],\n            order_fields={'field': 'metadata.name', 'order': 'asc'},\n            limit=20,\n        )\n        ```\n        this will match all entities of type group having a name starting\n        with 'A', ordered by name ascending.\n        The response will contain a maximum of 20 entities. In case\n        more than 20 entities exist, the response will contain a nextCursor\n        property that can be used to fetch the next batch of entities.\n\n        ```python\n        second_batch_response = await catalog_client\n            .query_entities(cursor=response.page_info.nextCursor)\n        ```\n        second_batch_response will contain the next batch of (maximum) 20 entities,\n        together with a prevCursor property, useful to fetch the previous batch.\n\n    \"\"\"\n    ...\n</code></pre>"},{"location":"models/","title":"Models","text":""},{"location":"models/#backstage_catalog_client.models.EntityFilterQuery","title":"<code>EntityFilterQuery = Sequence[EntityFilterItem]</code>  <code>module-attribute</code>","text":"<p>A key-value based filter expression for entities.</p> <p>Each key of a record is a dot-separated path into the entity structure, e.g. <code>metadata.name</code>. The values are literal values to match against. As a value you can also pass in the symbol <code>CATALOG_FILTER_EXISTS</code> (exported from this package), which means that you assert on the existence of that key, no matter what its value is. All matching of keys and values is case insensitive. If multiple filter sets are given as an array, then there is effectively an OR between each filter set. Within one filter set, there is effectively an AND between the various keys. Within one key, if there are more than one value, then there is effectively an OR between them. Example: For an input of <pre><code>[\n  { kind: ['API', 'Component'] },\n  { 'metadata.name': 'a', 'metadata.namespace': 'b' }\n]\n</code></pre></p> <p>This effectively means <pre><code>(kind = EITHER 'API' OR 'Component')\nOR\n(metadata.name = 'a' AND metadata.namespace = 'b' )\n</code></pre></p>"},{"location":"models/#backstage_catalog_client.models.CatalogRequestOptions","title":"<code>CatalogRequestOptions</code>","text":"<p>             Bases: <code>TypedDict</code></p> <p>Options you can pass into a catalog request for additional information.</p> Source code in <code>backstage_catalog_client/models.py</code> <pre><code>class CatalogRequestOptions(TypedDict, total=False):\n    \"\"\"Options you can pass into a catalog request for additional information.\"\"\"\n\n    token: str\n    \"\"\"an Authentication token for authenticated requests\"\"\"\n</code></pre>"},{"location":"models/#backstage_catalog_client.models.CatalogRequestOptions.token","title":"<code>token: str</code>  <code>instance-attribute</code>","text":"<p>an Authentication token for authenticated requests</p>"},{"location":"models/#backstage_catalog_client.models.EntityRef","title":"<code>EntityRef</code>  <code>dataclass</code>","text":"<p>all parts of a compound entity reference.</p> Source code in <code>backstage_catalog_client/models.py</code> <pre><code>@dataclass\nclass EntityRef:\n    \"\"\"all parts of a compound entity reference.\"\"\"\n\n    kind: str\n    name: str\n    namespace: str = \"default\"\n\n    def __str__(self) -&gt; str:\n        return f\"{self.kind}:{self.namespace}/{self.name}\"\n</code></pre>"},{"location":"models/#backstage_catalog_client.models.FullTextFilter","title":"<code>FullTextFilter</code>","text":"<p>             Bases: <code>TypedDict</code></p> Source code in <code>backstage_catalog_client/models.py</code> <pre><code>class FullTextFilter(TypedDict, total=False):\n    search_term: str\n    \"\"\"search term\"\"\"\n    search_fields: list[str]\n</code></pre>"},{"location":"models/#backstage_catalog_client.models.FullTextFilter.search_term","title":"<code>search_term: str</code>  <code>instance-attribute</code>","text":"<p>search term</p>"},{"location":"models/#backstage_catalog_client.models.GetEntitiesRequest","title":"<code>GetEntitiesRequest</code>","text":"<p>             Bases: <code>CatalogRequestOptions</code>, <code>TypedDict</code></p> Source code in <code>backstage_catalog_client/models.py</code> <pre><code>class GetEntitiesRequest(CatalogRequestOptions, TypedDict, total=False):\n    entity_filter: EntityFilterQuery\n    \"\"\"If given, only entities matching this filter will be returned.\"\"\"\n    fields: Sequence[str]\n    \"\"\"If given, return only the parts of each entity that match the field declarations.\"\"\"\n    order: EntityOrderQuery | Sequence[EntityOrderQuery]\n    \"\"\"If given, order the result set by those directives.\"\"\"\n    offset: int\n    \"\"\"If given, skips over the first N items in the result set.\"\"\"\n    limit: int\n    \"\"\"If given, returns at most N items from the result set.\"\"\"\n    after: str\n    \"\"\"If given, skips over all items before that cursor as returned by a previous request.\"\"\"\n</code></pre>"},{"location":"models/#backstage_catalog_client.models.GetEntitiesRequest.after","title":"<code>after: str</code>  <code>instance-attribute</code>","text":"<p>If given, skips over all items before that cursor as returned by a previous request.</p>"},{"location":"models/#backstage_catalog_client.models.GetEntitiesRequest.entity_filter","title":"<code>entity_filter: EntityFilterQuery</code>  <code>instance-attribute</code>","text":"<p>If given, only entities matching this filter will be returned.</p>"},{"location":"models/#backstage_catalog_client.models.GetEntitiesRequest.fields","title":"<code>fields: Sequence[str]</code>  <code>instance-attribute</code>","text":"<p>If given, return only the parts of each entity that match the field declarations.</p>"},{"location":"models/#backstage_catalog_client.models.GetEntitiesRequest.limit","title":"<code>limit: int</code>  <code>instance-attribute</code>","text":"<p>If given, returns at most N items from the result set.</p>"},{"location":"models/#backstage_catalog_client.models.GetEntitiesRequest.offset","title":"<code>offset: int</code>  <code>instance-attribute</code>","text":"<p>If given, skips over the first N items in the result set.</p>"},{"location":"models/#backstage_catalog_client.models.GetEntitiesRequest.order","title":"<code>order: EntityOrderQuery | Sequence[EntityOrderQuery]</code>  <code>instance-attribute</code>","text":"<p>If given, order the result set by those directives.</p>"},{"location":"models/#backstage_catalog_client.models.GetEntitiesResponse","title":"<code>GetEntitiesResponse</code>  <code>dataclass</code>","text":"<p>the repsonse type for getEntities</p> Source code in <code>backstage_catalog_client/models.py</code> <pre><code>@dataclass\nclass GetEntitiesResponse:\n    \"\"\"the repsonse type for getEntities\"\"\"\n\n    items: list[Entity]\n</code></pre>"},{"location":"models/#backstage_catalog_client.models.PageInfo","title":"<code>PageInfo</code>  <code>dataclass</code>","text":"Source code in <code>backstage_catalog_client/models.py</code> <pre><code>@dataclass\nclass PageInfo:\n    nextCursor: str | None = None\n    \"\"\"The cursor for the next batch of entities\"\"\"\n    prevCursor: str | None = None\n    \"\"\"The cursor for the previous batch of entities\"\"\"\n</code></pre>"},{"location":"models/#backstage_catalog_client.models.PageInfo.nextCursor","title":"<code>nextCursor: str | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The cursor for the next batch of entities</p>"},{"location":"models/#backstage_catalog_client.models.PageInfo.prevCursor","title":"<code>prevCursor: str | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The cursor for the previous batch of entities</p>"},{"location":"models/#backstage_catalog_client.models.QueryEntitiesKwargs","title":"<code>QueryEntitiesKwargs</code>","text":"<p>             Bases: <code>FullTextFilter</code>, <code>CatalogRequestOptions</code>, <code>TypedDict</code></p> Source code in <code>backstage_catalog_client/models.py</code> <pre><code>class QueryEntitiesKwargs(FullTextFilter, CatalogRequestOptions, TypedDict, total=False):\n    cursor: str\n    \"\"\"cursor for the next batch of entities\"\"\"\n    entity_filter: EntityFilterQuery\n    \"\"\"If given, only entities matching this filter will be returned.\"\"\"\n    fields: list[str]\n    \"\"\"If given, return only the parts of each entity that match the field declarations.\"\"\"\n    limit: int\n    \"\"\"controls the number of items per page;  default is 20\"\"\"\n    order_fields: list[EntityOrderQuery] | EntityOrderQuery\n    \"\"\"If given, order the result set by those directives.\"\"\"\n</code></pre>"},{"location":"models/#backstage_catalog_client.models.QueryEntitiesKwargs.cursor","title":"<code>cursor: str</code>  <code>instance-attribute</code>","text":"<p>cursor for the next batch of entities</p>"},{"location":"models/#backstage_catalog_client.models.QueryEntitiesKwargs.entity_filter","title":"<code>entity_filter: EntityFilterQuery</code>  <code>instance-attribute</code>","text":"<p>If given, only entities matching this filter will be returned.</p>"},{"location":"models/#backstage_catalog_client.models.QueryEntitiesKwargs.fields","title":"<code>fields: list[str]</code>  <code>instance-attribute</code>","text":"<p>If given, return only the parts of each entity that match the field declarations.</p>"},{"location":"models/#backstage_catalog_client.models.QueryEntitiesKwargs.limit","title":"<code>limit: int</code>  <code>instance-attribute</code>","text":"<p>controls the number of items per page;  default is 20</p>"},{"location":"models/#backstage_catalog_client.models.QueryEntitiesKwargs.order_fields","title":"<code>order_fields: list[EntityOrderQuery] | EntityOrderQuery</code>  <code>instance-attribute</code>","text":"<p>If given, order the result set by those directives.</p>"},{"location":"models/#backstage_catalog_client.models.QueryEntitiesResponse","title":"<code>QueryEntitiesResponse</code>  <code>dataclass</code>","text":"Source code in <code>backstage_catalog_client/models.py</code> <pre><code>@dataclass\nclass QueryEntitiesResponse:\n    items: list[Entity]\n    \"\"\"The list of entities for the current request\"\"\"\n    total_items: int\n    \"\"\"\"The number of entities among all the requests\"\"\"\n    page_info: PageInfo\n</code></pre>"},{"location":"models/#backstage_catalog_client.models.QueryEntitiesResponse.items","title":"<code>items: list[Entity]</code>  <code>instance-attribute</code>","text":"<p>The list of entities for the current request</p>"},{"location":"models/#backstage_catalog_client.models.QueryEntitiesResponse.total_items","title":"<code>total_items: int</code>  <code>instance-attribute</code>","text":"<p>\"The number of entities among all the requests</p>"},{"location":"sync-api/","title":"Sync API","text":""},{"location":"sync-api/#backstage_catalog_client.catalog_api.sync_api.SyncCatalogApi","title":"<code>SyncCatalogApi</code>","text":"<p>             Bases: <code>Protocol</code></p> Source code in <code>backstage_catalog_client/catalog_api/sync_api.py</code> <pre><code>class SyncCatalogApi(Protocol):\n    async def get_entities(\n        self,\n        **kwargs: Unpack[GetEntitiesRequest],\n    ) -&gt; GetEntitiesResponse:\n        \"\"\"\n        Gets entities from your backstage instance.\n\n        Args:\n            kwargs: The request object for getting entities. Defaults to None.\n\n        Returns:\n            The response object containing the entities.\n        \"\"\"\n        ...\n\n    async def query_entities(\n        self,\n        **kwargs: Unpack[QueryEntitiesKwargs],\n    ) -&gt; QueryEntitiesResponse:\n        \"\"\"\n        Gets paginated entities from the catalog.'\n\n        Args:\n            **kwargs: keyword arguments, represented as a dict.\n\n        Returns:\n            The response object containing the entities.\n\n        Examples:\n            ```python\n            response = await catalog_client.query_entities(\n                search_term='A',\n                entity_filter=[{\"kind\": \"User\"}],\n                order_fields={'field': 'metadata.name', 'order': 'asc'},\n                limit=20,\n            )\n            ```\n            this will match all entities of type group having a name starting\n            with 'A', ordered by name ascending.\n            The response will contain a maximum of 20 entities. In case\n            more than 20 entities exist, the response will contain a nextCursor\n            property that can be used to fetch the next batch of entities.\n\n            ```python\n            second_batch_response = await catalog_client\n                .query_entities(cursor=response.page_info.nextCursor)\n            ```\n            second_batch_response will contain the next batch of (maximum) 20 entities,\n            together with a prevCursor property, useful to fetch the previous batch.\n\n        \"\"\"\n        ...\n\n    async def get_entities_by_refs(\n        self,\n        refs: list[str | EntityRef],\n        **opts: Unpack[GetEntitiesByRefsOptions],\n    ) -&gt; GetEntitiesByRefsResponse:\n        \"\"\"\n        Gets a batch of entities, by their entity refs.\n        The output list of entities is of the same size and in the same order as\n        the requested list of entity refs. Entries that are not found are returned\n        as null.\n        \"\"\"\n        ...\n\n    async def get_entity_by_ref(\n        self,\n        ref: str | EntityRef,\n        **options: Unpack[CatalogRequestOptions],\n    ) -&gt; Entity | None:\n        \"\"\"\n        Gets a single entity from your backstage instance by reference (kind, namespace, name).\n\n        Args:\n            ref: The reference to the entity to fetch.\n            options: The options for the catalog request. Defaults to None.\n\n        Returns:\n            The entity if found, otherwise None.\n        \"\"\"\n\n        ...\n\n    async def get_location_by_entity(\n        self,\n        ref: str | EntityRef,\n        **opts: Unpack[CatalogRequestOptions],\n    ) -&gt; Location | None:\n        \"\"\"\n        Gets a location associated with an entity.\n\n        Args:\n            ref: The reference to the entity to fetch.\n            **opts: The options for the catalog request.\n\n        Returns:\n            the location if found, otherwise None.\n        \"\"\"\n        ...\n</code></pre>"},{"location":"sync-api/#backstage_catalog_client.catalog_api.sync_api.SyncCatalogApi.get_entities","title":"<code>get_entities(**kwargs)</code>  <code>async</code>","text":"<p>Gets entities from your backstage instance.</p> <p>Parameters:</p> Name Type Description Default <code>kwargs</code> <code>Unpack[GetEntitiesRequest]</code> <p>The request object for getting entities. Defaults to None.</p> <code>{}</code> <p>Returns:</p> Type Description <code>GetEntitiesResponse</code> <p>The response object containing the entities.</p> Source code in <code>backstage_catalog_client/catalog_api/sync_api.py</code> <pre><code>async def get_entities(\n    self,\n    **kwargs: Unpack[GetEntitiesRequest],\n) -&gt; GetEntitiesResponse:\n    \"\"\"\n    Gets entities from your backstage instance.\n\n    Args:\n        kwargs: The request object for getting entities. Defaults to None.\n\n    Returns:\n        The response object containing the entities.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"sync-api/#backstage_catalog_client.catalog_api.sync_api.SyncCatalogApi.get_entities_by_refs","title":"<code>get_entities_by_refs(refs, **opts)</code>  <code>async</code>","text":"<p>Gets a batch of entities, by their entity refs. The output list of entities is of the same size and in the same order as the requested list of entity refs. Entries that are not found are returned as null.</p> Source code in <code>backstage_catalog_client/catalog_api/sync_api.py</code> <pre><code>async def get_entities_by_refs(\n    self,\n    refs: list[str | EntityRef],\n    **opts: Unpack[GetEntitiesByRefsOptions],\n) -&gt; GetEntitiesByRefsResponse:\n    \"\"\"\n    Gets a batch of entities, by their entity refs.\n    The output list of entities is of the same size and in the same order as\n    the requested list of entity refs. Entries that are not found are returned\n    as null.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"sync-api/#backstage_catalog_client.catalog_api.sync_api.SyncCatalogApi.get_entity_by_ref","title":"<code>get_entity_by_ref(ref, **options)</code>  <code>async</code>","text":"<p>Gets a single entity from your backstage instance by reference (kind, namespace, name).</p> <p>Parameters:</p> Name Type Description Default <code>ref</code> <code>str | EntityRef</code> <p>The reference to the entity to fetch.</p> required <code>options</code> <code>Unpack[CatalogRequestOptions]</code> <p>The options for the catalog request. Defaults to None.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Entity | None</code> <p>The entity if found, otherwise None.</p> Source code in <code>backstage_catalog_client/catalog_api/sync_api.py</code> <pre><code>async def get_entity_by_ref(\n    self,\n    ref: str | EntityRef,\n    **options: Unpack[CatalogRequestOptions],\n) -&gt; Entity | None:\n    \"\"\"\n    Gets a single entity from your backstage instance by reference (kind, namespace, name).\n\n    Args:\n        ref: The reference to the entity to fetch.\n        options: The options for the catalog request. Defaults to None.\n\n    Returns:\n        The entity if found, otherwise None.\n    \"\"\"\n\n    ...\n</code></pre>"},{"location":"sync-api/#backstage_catalog_client.catalog_api.sync_api.SyncCatalogApi.get_location_by_entity","title":"<code>get_location_by_entity(ref, **opts)</code>  <code>async</code>","text":"<p>Gets a location associated with an entity.</p> <p>Parameters:</p> Name Type Description Default <code>ref</code> <code>str | EntityRef</code> <p>The reference to the entity to fetch.</p> required <code>**opts</code> <code>Unpack[CatalogRequestOptions]</code> <p>The options for the catalog request.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Location | None</code> <p>the location if found, otherwise None.</p> Source code in <code>backstage_catalog_client/catalog_api/sync_api.py</code> <pre><code>async def get_location_by_entity(\n    self,\n    ref: str | EntityRef,\n    **opts: Unpack[CatalogRequestOptions],\n) -&gt; Location | None:\n    \"\"\"\n    Gets a location associated with an entity.\n\n    Args:\n        ref: The reference to the entity to fetch.\n        **opts: The options for the catalog request.\n\n    Returns:\n        the location if found, otherwise None.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"sync-api/#backstage_catalog_client.catalog_api.sync_api.SyncCatalogApi.query_entities","title":"<code>query_entities(**kwargs)</code>  <code>async</code>","text":"<p>Gets paginated entities from the catalog.'</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <code>Unpack[QueryEntitiesKwargs]</code> <p>keyword arguments, represented as a dict.</p> <code>{}</code> <p>Returns:</p> Type Description <code>QueryEntitiesResponse</code> <p>The response object containing the entities.</p> <p>Examples:</p> <p><pre><code>response = await catalog_client.query_entities(\n    search_term='A',\n    entity_filter=[{\"kind\": \"User\"}],\n    order_fields={'field': 'metadata.name', 'order': 'asc'},\n    limit=20,\n)\n</code></pre> this will match all entities of type group having a name starting with 'A', ordered by name ascending. The response will contain a maximum of 20 entities. In case more than 20 entities exist, the response will contain a nextCursor property that can be used to fetch the next batch of entities.</p> <p><pre><code>second_batch_response = await catalog_client\n    .query_entities(cursor=response.page_info.nextCursor)\n</code></pre> second_batch_response will contain the next batch of (maximum) 20 entities, together with a prevCursor property, useful to fetch the previous batch.</p> Source code in <code>backstage_catalog_client/catalog_api/sync_api.py</code> <pre><code>async def query_entities(\n    self,\n    **kwargs: Unpack[QueryEntitiesKwargs],\n) -&gt; QueryEntitiesResponse:\n    \"\"\"\n    Gets paginated entities from the catalog.'\n\n    Args:\n        **kwargs: keyword arguments, represented as a dict.\n\n    Returns:\n        The response object containing the entities.\n\n    Examples:\n        ```python\n        response = await catalog_client.query_entities(\n            search_term='A',\n            entity_filter=[{\"kind\": \"User\"}],\n            order_fields={'field': 'metadata.name', 'order': 'asc'},\n            limit=20,\n        )\n        ```\n        this will match all entities of type group having a name starting\n        with 'A', ordered by name ascending.\n        The response will contain a maximum of 20 entities. In case\n        more than 20 entities exist, the response will contain a nextCursor\n        property that can be used to fetch the next batch of entities.\n\n        ```python\n        second_batch_response = await catalog_client\n            .query_entities(cursor=response.page_info.nextCursor)\n        ```\n        second_batch_response will contain the next batch of (maximum) 20 entities,\n        together with a prevCursor property, useful to fetch the previous batch.\n\n    \"\"\"\n    ...\n</code></pre>"}]}